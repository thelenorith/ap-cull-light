"""
Generated By: Cursor (Claude Sonnet 4.5)

Main module for culling astrophotography light frames based on FITS header rules.
"""

import argparse
import logging
import os
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import ap_common
from ap_common import NORMALIZED_HEADER_HFR, NORMALIZED_HEADER_RMSAC, TYPE_LIGHT
from ap_common.logging_config import setup_logging
from ap_common.progress import progress_iter, ProgressTracker
from . import config

# Configure logging
logger = logging.getLogger(__name__)

# Set default description width for aligned progress bars
ProgressTracker.set_default_desc_width(20)


def reject_image(
    filepath: str,
    reject_dir: str,
    source_dir: str,
    dryrun: bool = False,
    debug: bool = False,
) -> None:
    """
    Move an image to the reject directory, preserving relative directory structure.

    Args:
        filepath: Full path to the file to reject
        reject_dir: Root directory for rejected images
        source_dir: Source directory (to compute relative path)
        dryrun: If True, don't actually move the file
        debug: If True, print debug information
    """
    filepath_obj = Path(filepath)
    source_path = Path(source_dir).resolve()
    filepath_resolved = filepath_obj.resolve()

    # Compute relative path from source directory
    try:
        relative_path = filepath_resolved.relative_to(source_path)
    except ValueError:
        # File is not under source_dir, use just the filename
        relative_path = Path(filepath_obj.name)

    # Create destination path
    dest_path = Path(reject_dir) / relative_path
    dest_dir = dest_path.parent

    # Verify destination is under reject_dir (safety check)
    reject_path = Path(reject_dir).resolve()
    dest_resolved = dest_path.resolve()
    # Use proper path comparison - check if dest is relative to reject_path
    try:
        dest_resolved.relative_to(reject_path)
    except ValueError:
        # dest_resolved is not under reject_path - security violation
        raise ValueError(
            f"ERROR: Attempting to move file to invalid location outside reject_dir!\n"
            f"  filepath: {filepath}\n"
            f"  reject_dir: {reject_dir}\n"
            f"  dest_path: {dest_path}\n"
            f"  dest_resolved: {dest_resolved}"
        )

    if dryrun:
        logger.debug(f"[DRYRUN] Would reject: {relative_path}")
    else:
        try:
            # Create destination directory
            dest_dir.mkdir(parents=True, exist_ok=True)

            # Move the file
            ap_common.move_file(
                from_file=str(filepath), to_file=str(dest_path), debug=debug
            )
            logger.debug(f"Rejected: {relative_path}")
        except OSError as e:
            error_msg = f"Failed to move file {relative_path}: {e}"
            logger.error(error_msg)
            raise
        except Exception as e:
            error_msg = f"Unexpected error moving file {relative_path}: {e}"
            logger.error(error_msg, exc_info=debug)
            raise


def cull_lights(
    source_dir: str,
    reject_dir: str,
    max_hfr: Optional[float] = None,
    max_rms: Optional[float] = None,
    auto_yes_percent: float = -1,
    skip_pattern: Optional[re.Pattern] = None,
    debug: bool = False,
    dryrun: bool = False,
    quiet: bool = False,
) -> None:
    """
    Cull light frames based on HFR and RMS thresholds.

    Args:
        source_dir: Source directory containing light frames
        reject_dir: Directory to move rejected images to
        max_hfr: Maximum HFR value (reject if HFR > max_hfr)
        max_rms: Maximum RMS in arcsec (reject if RMS > max_rms)
        auto_yes_percent: Auto-accept if rejection percentage is below this (0.0-100.0, default: -1 = prompt always)
        skip_pattern: Compiled regex pattern - files matching the pattern will be skipped
        debug: Enable debug output
        dryrun: Perform dry run without actually moving files
        quiet: Suppress progress output
    """
    # Print operation summary upfront
    thresholds = []
    if max_hfr is not None:
        thresholds.append(f"HFR<={max_hfr}")
    if max_rms is not None:
        thresholds.append(f"RMS<={max_rms} arcsec")

    print(f"Culling lights from: {source_dir}")
    print(f"Thresholds: {', '.join(thresholds)}")
    if dryrun:
        print("Mode: DRY RUN (no files will be moved)")
    print()

    # Get metadata for all FITS files
    required_properties: list[str] = (
        []
    )  # No specific requirements, rules engine handles missing headers
    data = ap_common.get_filtered_metadata(
        dirs=[source_dir],
        patterns=[config.INPUT_PATTERN_ALL],
        recursive=True,
        required_properties=required_properties,
        filters={"type": TYPE_LIGHT},
        debug=debug,
        profileFromPath=True,
        printStatus=not quiet,
    )

    # Group files by directory (for batch rejection confirmation)
    data_groups: Dict[str, List[Dict[str, Any]]] = {}

    for filename, metadata in data.items():
        # Skip files matching skip pattern
        if skip_pattern and skip_pattern.search(filename):
            if debug:
                logger.debug(
                    f"Skipping {filename} (matches pattern: {skip_pattern.pattern})"
                )
            continue

        # Get directory path (use resolved path for consistent grouping)
        directory = str(Path(filename).resolve().parent)

        if directory not in data_groups:
            data_groups[directory] = []
        data_groups[directory].append(metadata)

    if debug:
        logger.debug(f"Found {len(data_groups)} directory groups")
        for dir_path, files in data_groups.items():
            logger.debug(f"  {dir_path}: {len(files)} files")

    # Evaluate rejections for all directory groups with progress
    rejection_decisions: List[Tuple[str, List[Tuple[str, List[str]]], int, int]] = []
    overall_count_total = sum(len(files) for files in data_groups.values())

    for directory, file_metadata_list in progress_iter(
        data_groups.items(), desc="Evaluating files", unit="dirs", enabled=not quiet
    ):
        count_reject = 0
        count_total = len(file_metadata_list)
        rejected_files = []

        # Evaluate thresholds for each file
        for metadata in file_metadata_list:
            reasons = []
            should_reject = False

            # Check HFR threshold
            if max_hfr is not None:
                hfr_value = metadata.get(NORMALIZED_HEADER_HFR)
                if hfr_value is not None:
                    try:
                        hfr_float = float(hfr_value)
                        if hfr_float > max_hfr:
                            should_reject = True
                            reasons.append(f"HFR={hfr_float} > {max_hfr}")
                    except (ValueError, TypeError):
                        if debug:
                            filename_for_log = metadata.get("filename", "unknown")
                            logger.warning(
                                f"Skipping HFR check for {filename_for_log}: "
                                f"non-numeric HFR value '{hfr_value}'"
                            )

            # Check RMS threshold
            if max_rms is not None:
                rms_value = metadata.get(NORMALIZED_HEADER_RMSAC)
                if rms_value is not None:
                    try:
                        rms_float = float(rms_value)
                        if rms_float > max_rms:
                            should_reject = True
                            reasons.append(f"RMS={rms_float} > {max_rms} arcsec")
                    except (ValueError, TypeError):
                        if debug:
                            filename_for_log = metadata.get("filename", "unknown")
                            logger.warning(
                                f"Skipping RMS check for {filename_for_log}: "
                                f"non-numeric RMS value '{rms_value}'"
                            )

            if should_reject:
                count_reject += 1
                filename = metadata.get("filename")
                if filename is None:
                    logger.warning(
                        "Metadata missing 'filename' field, skipping rejection"
                    )
                    continue
                rejected_files.append((filename, reasons))

        # Store rejection decision for later processing
        if count_reject > 0:
            rejection_decisions.append(
                (directory, rejected_files, count_reject, count_total)
            )

    # Process rejection decisions with user confirmation
    overall_count_reject = 0
    files_to_reject: List[str] = []
    rejection_summary: List[Tuple[str, int, int, float]] = []

    for directory, rejected_files, count_reject, count_total in rejection_decisions:
        dir_short = directory.replace(source_dir, "").lstrip(os.sep)
        rejection_percent = 100 * count_reject / count_total

        # Determine if we should auto-accept
        if auto_yes_percent >= 0 and rejection_percent < auto_yes_percent:
            answer = "y"
        elif dryrun:
            answer = "y"
        else:
            # Prompt user
            question = (
                f"Reject {count_reject}/{count_total} ({rejection_percent:.1f}%) "
                f"from '{dir_short}'? (y/N) "
            )
            answer = input(question).strip().lower()

        if answer == "y":
            overall_count_reject += count_reject
            files_to_reject.extend([filename for filename, _ in rejected_files])
            rejection_summary.append(
                (dir_short, count_reject, count_total, rejection_percent)
            )
        else:
            logger.info(f"Skipped rejection for {dir_short}")

    # Move rejected files with progress
    if files_to_reject:
        for filepath in progress_iter(
            files_to_reject, desc="Rejecting files", unit="files", enabled=not quiet
        ):
            reject_image(
                filepath=filepath,
                reject_dir=reject_dir,
                source_dir=source_dir,
                dryrun=dryrun,
                debug=debug,
            )

    # Print formatted summary table
    if rejection_summary:
        print("\n" + "=" * 80)
        print("REJECTION SUMMARY")
        print("=" * 80)

        # Table header
        print(f"{'Target/Filter':<50} {'Rejected':>12} {'%':>8}")
        print("-" * 80)

        # Parse and group by target/filter
        grouped_summary: Dict[str, Tuple[int, int]] = {}
        for dir_short, count_reject, count_total, _ in rejection_summary:
            # Extract meaningful parts from path
            # Format: Target\DATE_xxx\FILTER_x_EXP_x_SETTEMP_x
            parts = dir_short.split(os.sep)
            if len(parts) >= 3:
                target = parts[0]
                filter_part = parts[2] if len(parts) > 2 else "unknown"
                # Extract just the filter name (FILTER_X)
                filter_match = re.search(r"FILTER_([^_]+)", filter_part)
                filter_name = filter_match.group(1) if filter_match else "unknown"
                key = f"{target} / {filter_name}"
            else:
                key = dir_short

            if key not in grouped_summary:
                grouped_summary[key] = (0, 0)
            current_reject, current_total = grouped_summary[key]
            grouped_summary[key] = (
                current_reject + count_reject,
                current_total + count_total,
            )

        # Print grouped rows
        for key in sorted(grouped_summary.keys()):
            count_reject, count_total = grouped_summary[key]
            rejection_percent = (
                100 * count_reject / count_total if count_total > 0 else 0
            )
            print(
                f"{key:<50} {count_reject:>5}/{count_total:<5} {rejection_percent:>7.1f}%"
            )

        # Print total row
        print("-" * 80)
        overall_percent = (
            100 * overall_count_reject / overall_count_total
            if overall_count_total > 0
            else 0
        )
        print(
            f"{'TOTAL':<50} {overall_count_reject:>5}/{overall_count_total:<5} {overall_percent:>7.1f}%"
        )
        print("=" * 80)
    elif overall_count_total > 0:
        print(f"\nNo files rejected (0 of {overall_count_total})")

    print(f"\nDone with: {source_dir}")


def main() -> None:
    """Main entry point for the command-line interface."""
    parser = argparse.ArgumentParser(
        description="Cull astrophotography light frames based on FITS header rules"
    )
    parser.add_argument(
        "source_dir",
        type=str,
        help="Source directory containing light frames to cull",
    )
    parser.add_argument(
        "reject_dir",
        type=str,
        help="Directory to move rejected images to (relative structure preserved)",
    )

    parser.add_argument(
        "--max-hfr",
        type=float,
        default=None,
        help="Maximum HFR value (reject if HFR > max_hfr)",
    )
    parser.add_argument(
        "--max-rms",
        type=float,
        default=None,
        help="Maximum RMS in arcsec (reject if RMS > max_rms)",
    )
    parser.add_argument(
        "--auto-accept-percent",
        type=float,
        default=-1,
        help="Auto-accept if rejection percentage is below this (0.0-100.0, default: -1 = always prompt)",
    )
    parser.add_argument(
        "--skip-regex",
        type=str,
        default=None,
        help="Regex pattern to skip files/directories (e.g., 'accept' or 'accept|processed' to skip multiple patterns)",
    )

    parser.add_argument("--debug", action="store_true", help="Enable debug output")
    parser.add_argument(
        "--dryrun", action="store_true", help="Perform dry run without moving files"
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress progress output"
    )

    args = parser.parse_args()

    # Configure logging
    setup_logging(name="ap_cull_light", debug=args.debug, quiet=args.quiet)

    # Validate at least one threshold is specified
    if args.max_hfr is None and args.max_rms is None:
        parser.error("Must specify at least one of --max-hfr or --max-rms")

    # Validate auto-accept-percent range
    if args.auto_accept_percent != -1:
        if args.auto_accept_percent < 0.0 or args.auto_accept_percent > 100.0:
            parser.error(
                f"--auto-accept-percent must be between 0.0 and 100.0 (got {args.auto_accept_percent})"
            )

    # Compile skip pattern
    skip_pattern = None
    if args.skip_regex:
        try:
            skip_pattern = re.compile(args.skip_regex)
        except re.error as e:
            parser.error(f"Invalid regex pattern in --skip-regex: {e}")

    # Validate directories
    source_path = Path(args.source_dir)
    reject_path = Path(args.reject_dir)

    if not source_path.exists():
        parser.error(f"Source directory does not exist: {args.source_dir}")

    if not source_path.is_dir():
        parser.error(f"Source path is not a directory: {args.source_dir}")

    # Check if source and reject directories are the same
    if source_path.resolve() == reject_path.resolve():
        parser.error(
            f"Source and reject directories cannot be the same: {args.source_dir}"
        )

    # Run culling
    cull_lights(
        source_dir=args.source_dir,
        reject_dir=args.reject_dir,
        max_hfr=args.max_hfr,
        max_rms=args.max_rms,
        auto_yes_percent=args.auto_accept_percent,
        skip_pattern=skip_pattern,
        debug=args.debug,
        dryrun=args.dryrun,
        quiet=args.quiet,
    )


if __name__ == "__main__":
    main()
